# C++

## 指针

1.悬空指针

定义：指针被释放后，还指向原来的内存空间。如：

```c++
void *p = malloc(size);
assert(p);
free(p);
//此时p为悬空指针
```

避免方法：

```c++
void *p = malloc(size);
assert(p);
free(p);
p = NULL;//赋值为NULL来避免悬空指针
```

2.野指针

定义：指针不确定其具体指向的内存空间。如：

```c++
void *p;
//此时p为野指针
```

危害：可能指向任意内存段，因此它可能会损坏正常的数据，也有可能引发其他未知错误。

避免方法：

```c++
void *p = NULL;
```



## 运算符重载

```c++
函数类型 operator运算符(形参列表)
{
    重载语句;
}
```

`operator`为关键字，专门用于定义运算符重载的函数。可以将 **operator运算符** 看成函数名称。

#### 运算符重载规则：

1.并不是所有的运算符都能被重载，如长度运算符`sizeof`、条件运算符`: ?`（三元运算符）、成员选择符`.`和域解析运算符`::`不能被重载。

2.重载不能改变运算符的优先级和结合性。

3.重载不改变运算符的用法（即不改变原先的使用规则）。

4.运算符重载函数**不能有默认参数**，因为这会改变运算符操作数个数。

5.运算符重载函数既可以作为**类的成员函数**，也可以作为**全局函数**。

将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的。当类的对象调用重载后的运算符时，此对象就隐形作为一个参数了。

将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，**而且其中必须有一个参数是对象**，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质。

6.箭头运算符`->`、下标运算符`[ ]`、函数调用运算符`( )`、赋值运算符`=`只能以成员函数的形式重载。

#### 流操作符重载

输入流操作符`>>`和输出流操作符`<<`。

`cout`是`ostream类`对象，`cin`是`iostream类`对象。

```C++
//输入流操作符>>重载
istream & operator>>(istream &in, 类型 &A)
{
    in >> A.成员1 >> A.成员2;
    return in;
}
//返回 istream 类对象的引用，是为了能够连续读取复数，让代码书写更加漂亮

//输出流操作符<<重载
ostream & operator<<(ostream &out, 类型 &A)
{
    out << A.成员1 << A.成员2;
    return out;
}
```

#### 下标运算符`[]`重载

只能以成员函数的形式进行重载，声明格式一般为：

```C++
//第一种方式:不仅可以访问元素，还可以修改元素。
返回值类型 & operator[](形参);
//第二种方式:只能访问而不能修改元素
const 返回值类型 & operator[](形参) const;
```

可以通过重载`[]`来实现变长数组。

```C++
class Array{
public:
    Array(int length = 0);
    ~Array();
    int & operator[](int i);
    const int & operator[](int i) const;
private:
    int m_length;  //数组长度
    int *m_p;  //指向数组内存的指针
};
Array::~Array(){
    delete[] m_p;
}
int& Array::operator[](int i){
    return m_p[i];
}
const int & Array::operator[](int i) const{
    return m_p[i];
}
```

